<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electon Capture App | Live Social Messaging for Content Creators</title>
    <meta name="description" content="Electon Capture App consolidates live social messaging from YouTube, Twitch, Facebook, TikTok and more into a customizable dashboard. Enhance your live streaming with chat overlays, bot actions, and text-to-speech.">
    <meta name="keywords" content="social stream, live chat, OBS overlay, chat relay, multi-platform chat, content creators, live streaming tools">
    <meta name="author" content="Electon Capture App">
    <link rel="icon" type="image/x-icon" href="./icons/favicon.ico">
    <link rel="stylesheet" href="styles.css">
    <script async defer src="./thirdparty/buttons.js"></script>
    <script src="./thirdparty/marked.umd.min.js"></script>
    <script src="./thirdparty/index.umd.min.js"></script>
    <meta property="og:title" content="Electon Capture App | Enhance Your Live Streaming">
    <meta property="og:description" content="Easily integrate chat messages from various platforms like YouTube, Twitch, and Facebook into your live streams with Electon Capture App.">
    <meta property="og:url" content="https://electroncapture.app">
    <meta property="og:type" content="website">
    <meta name="twitter:title" content="Electon Capture App | Live Chat Integration for Streamers">
    <meta name="twitter:description" content="Electon Capture App, a free tool for streamers, integrates live chat from multiple platforms directly into OBS. Discover more at electroncapture.app">
    <link rel="canonical" href="https://electroncapture.app/landing" />
    <style>

		
@import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap');

body, html {
    margin: 0;
    padding: 0;
    font-family: 'Poppins', sans-serif;
    color: #333;
    background-color: #e5e5e5;
	padding-bottom: 40px;
	line-height: 1.6;
	overflow-x: hidden;
}

header {
    background: #1a1a1a; /* Darker shade for a rich appearance */
    color: #fff;
    padding: 20px;
    text-align: center;
}

h1 {
    margin: 0;
    font-size: 2.4em;
}

#markdown h1 {
	display:none;
}

p {
    margin: 10px 0 0;
    font-size: 1.2em;
}

#downloads {
    text-align: center;
    padding: 20px;
}

.download-btn {
    background-color: #007bff; /* Brighter shade of blue */
    color: white;
    border: none;
    padding: 15px 32px;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-size: 16px;
    margin: 4px 2px;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s;
}

.download-btn:hover {
    background-color: #0056b3; /* Darker blue on hover */
	color: white;
}

#video {
    width: 100%;
    text-align: center;
    padding: 20px;
	max-width: calc(100% - 40px);
}

iframe {
    max-width: 100%;
    border: none; /* Remove border for cleaner look */
}

.section {
    padding: 20px 20px 40px 20px;
    background-color: #fff;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
	margin: 20px;
    border-radius: 10px;
}

.faq-item h3 {
    margin: 10px 0;
    color: #333;
}

.faq-item p {
    font-size: 1em;
    color: #666;
}

footer {
    background-color: #1a1a1a;
    color: white;
    text-align: center;
    padding: 10px;
    position: fixed;
    bottom: 0;
    width: 100vw;
}
footer p {
	margin: 0;
}

a {
    color: #007bff; /* Links color to match buttons */
    text-decoration: none;
}

a:hover {
    color: #0056b3; /* Darker blue on hover */
    text-decoration: underline; /* Underline on hover for better visibility */
}

.github-btn {
    background-color: #cecece;
    color: black;
    border: none;
    padding: 12px 20px;
    font-size: 16px;
    border-radius: 5px;
    text-decoration: none;
    display: inline-block;
    transition: background-color 0.3s;
    margin-top: 12px;
}

.github-btn:hover {
    background-color: #b0aeae; 
}

#github-buttons {
    text-align: center; 
    margin: 20px 0 10px 0; 
}
.logo{
	max-height: 1.2em;
}

#content {
    background-color: #f8f8f8;
    padding: 20px;
    border-radius: 8px;
    border: 1px solid #ddd;
}

#content h1, #content h2, #content h3 {
    color: #333;
}

#content pre, #content code {
    background-color: #eee;
    border-radius: 5px;
    padding: 5px;
    font-family: 'Courier New', Courier, monospace;
}

#content a {
    color: #007BFF;
    text-decoration: none;
}

img {
	max-width: 100%;
}

#notice {
    background-color: #fffbe6;
    border: 1px solid #ffe58f;
    border-radius: 4px;
    padding: 16px;
    margin: 20px;
    font-size: 14px;
    line-height: 1.5;
}

#notice-header {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
}

#notice-header::before {
    content: "\26A0"; /* Unicode for warning sign */
    font-size: 24px;
    margin-right: 10px;
    color: #faad14;
}

#notice strong {
    color: #d46b08;
}

#notice a {
    color: #1890ff;
    text-decoration: none;
}

#notice a:hover {
    text-decoration: underline;
}

#notice ol {
    margin-top: 10px;
    margin-bottom: 10px;
    padding-left: 20px;
}
</style>


	</style>
</head>
<body>
    <header>
    </header>

   
	<section id="markdown" class="section">
		
	</section>
	<script>
		// Function to handle smooth scrolling to anchor with retry logic
		function scrollToAnchor(hash, retryCount = 0, maxRetries = 3) {
		    // Remove the # from the hash
		    const targetId = hash.replace('#', '');
		    
		    // Look for either the ID or a heading with matching text
		    let targetElement = document.getElementById(targetId);
		    
		    if (!targetElement) {
		        // If no direct ID match, try to find a heading that matches
		        const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
		        for (const heading of headings) {
		            // Convert heading text to kebab case for comparison
		            const headingId = heading.textContent.toLowerCase()
		                .replace(/[^\w\s-]/g, '')
		                .replace(/\s+/g, '-');
		            
		            if (headingId === targetId) {
		                targetElement = heading;
		                break;
		            }
		        }
		    }
		    
		    if (targetElement) {
		        // Wait for images to load in the markdown container
		        const images = document.querySelectorAll('#markdown img');
		        const imagePromises = Array.from(images).map(img => {
		            if (img.complete) return Promise.resolve();
		            return new Promise(resolve => {
		                img.onload = resolve;
		                img.onerror = resolve; // Handle failed image loads
		            });
		        });
		
		        // After images load (or fail), scroll to target
		        Promise.all(imagePromises).then(() => {
		            // Additional small delay to ensure final layout
		            setTimeout(() => {
		                const offset = targetElement.getBoundingClientRect().top + window.scrollY - 20; // 20px padding
		                window.scrollTo({
		                    top: offset,
		                    behavior: 'smooth'
		                });
		                
		                // Verify scroll position after a short delay
		                setTimeout(() => {
		                    const elementPosition = targetElement.getBoundingClientRect().top;
		                    // If element is not close to top of viewport and we haven't exceeded max retries
		                    if (Math.abs(elementPosition) > 50 && retryCount < maxRetries) {
		                        scrollToAnchor(hash, retryCount + 1, maxRetries);
		                    }
		                }, 500);
		            }, 100);
		        });
		    }
		}

		function smoothScroll(target) {
			  const element = document.getElementById(target);
			  if (element) {
				window.scrollTo({
				  top: element.offsetTop,
				  behavior: 'smooth'
				});
			  }
			}
		if (location.protocol.startsWith('http')) {
			document.addEventListener("DOMContentLoaded", function() {
			    if (location.protocol.startsWith('http')) {
			        marked.use(markedGfmHeadingId.gfmHeadingId({}));
			        
			        fetch('./README.md')
			            .then(response => response.text())
			            .then(text => {
			                const html = marked.parse(text);
			                document.getElementById('markdown').innerHTML = html;
			                
			                // After content is updated, check for hash and scroll if needed
			                if (window.location.hash) {
			                    scrollToAnchor(window.location.hash);
			                }
			            })
			            .catch(error => console.error('Error loading the README:', error));
			    }
			});
		} else {
			console.warn('Skipping fetch call since the page is loaded locally.');
		}
		window.addEventListener('hashchange', function() {
		    if (window.location.hash) {
		        scrollToAnchor(window.location.hash);
		    }
		});
	</script>
</body>
</html>
